<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">require(['jquery', 'backbone', 'underscore',
    'renderers/network', 'util/progress', 'util/hud', 'util/viewport',
    'util/graph', 'network/nav', 'network/blurb', 'util/help', 'util/modal'],
    function (JQ, Backbone, _, NetworkVis, Progress, HUD, Viewport, Graph, Nav,
        Blurb, Help, Modal) {
        
    var neighborTemplate = _.template(&quot;/data/node/&lt;%= id %&gt;/neighbors&quot;);
    var networkTemplate  = _.template(&quot;/data/network/&lt;%= id %&gt;&quot;);
    var internalTemplate = _.template(&quot;/data/network/internal&quot;);
    var datasetsTemplate = _.template(&quot;/data/node/&lt;%= id %&gt;/datasets&quot;);
    var datasetLinkItemTemplate = _.template(
        &quot;&lt;li&gt;&lt;a href=\&quot;&lt;%=link%&gt;\&quot; title=\&quot;&lt;%=desc%&gt;\&quot;&gt;&lt;%=name%&gt;&lt;/a&gt;&lt;/li&gt;&quot;);
    var neighborQueryTemplate = _.template(&quot;/data/query/network/neighbors&quot;);

    var App, Search, router, AppProgress;
    var resetNetwork = true;
    var clusters = [];
    var blurb, modal = new Modal();
        
    AppProgress = new Progress({
        element: &quot;#progress-indicator&quot;,
        fade: false,
        type: Progress.BAR
    });
    var NetworkModel = Backbone.Model.extend({
        parse: function (data) { this.set(data); },
    });
    var NetworkData = new NetworkModel;
    var Datavis = new NetworkVis({
        element: JQ(&quot;#datavis&quot;),
        dock: true,
        joinAttribute: &quot;entityId&quot;,
        nodeLabel: { type: &quot;CLUSTER&quot; }
    });
    function setLayout() {
        JQ(&quot;#datavis&quot;).empty();
        var viewport = new Viewport({
            parent: &quot;#datavis&quot;,
            title: &quot;Network&quot;,
            maximize: false
        });
        Datavis.setElement(viewport);
        viewport.renderer(Datavis);
    }
    Datavis.on(&quot;dblclick-node&quot;, function (evt, node, element) {
        evt.stopPropagation();
        if (node.isExpanded) {
            Datavis.collapse(node);
            node.isExpanded = false;
            node.isCollapsed = true;
            return;
        } else if (node.isCollapsed) {
            Datavis.uncollapse(node);
            node.isCollapsed = false;
            node.isExpanded = true;
            return;
        }
        resetNetwork = false;
        if (DataSets.get('datasets') == null) {
            router.navigate(&quot;#node/&quot; + node.entityId + &quot;/datasets&quot;, true);
        } else {
            if (node.type == 'CLUSTER') {
                var docked = Datavis.dock.get();
                coNeighborAction([ node ], docked);
            } else {
                if (DataSets.asString() == 'fake') {
                    JQ.ajax({
                        url: neighborTemplate({ id: node.entityId }),
                        dataType: 'json',
                        data: { datasets: DataSets.asString() }
                    }).done(function (n) {
                        Datavis.merge(n);
                    });
            
                    // FIXME: This stopped working for some reason
                    //        Getting objects within edge.source/link
                    // router.navigate(&quot;#node/&quot; + node.name + &quot;/datasets/&quot; +
                    //      DataSets.asString() +
                    //      &quot;/neighbors&quot;, true);
                }
            }
        }
        node.isExpanded = true;
    });
    
    Datavis.on(&quot;click-node&quot;, function (evt, node, element) {
        Datavis.clickNode(node, element);
    });
    var nodeClusters = {};
    Datavis.addDockAction(function (nodes) {
        var dock = this;
        var button = JQ(&quot;&lt;button&gt;&quot;)
            .addClass(&quot;btn btn-small btn-primary&quot;)
            .attr(&quot;id&quot;, &quot;btn-get-clusters&quot;)
            .html(&quot;&lt;i class=\&quot;icon-plus-sign\&quot;&gt;&lt;/i&gt; Clusters&quot;);
        button.on(&quot;click&quot;, function () {
            AppProgress.progress(0);
            AppProgress.show(&quot;Getting clusters&quot;);
            var deferred = JQ.Deferred(), chained = deferred;
            var nodesDone = 0;
            function incProgress() {
                nodesDone++;
                AppProgress.progress(
                    nodesDone / nodes.length * 100 + &quot;%&quot;);
            }
            nodes.forEach(function (node) {
                var entityId = node.entityId;
                chained = chained.then(function() {
                    if (nodeClusters[entityId]) {
                        incProgress();
                        return true;
                    }
                    var neighbors = new NetworkModel;
                    neighbors.url = neighborTemplate({ id: entityId });
                    var promise = JQ.Deferred();
                    neighbors.fetch({
                        data: {
                            datasets: DataSets.asString(),
                            rels: &quot;gc&quot; // GENE:CLUSTER
                        },
                        success: function(model, data) {
                            nodeClusters[entityId] = true;
                            incProgress();
                            if (!data) { promise.resolve(); return; }
                            data.nodes.forEach(function(node, ni) {
                                if (node.type == 'CLUSTER') {
                                    // Associate primary dataset with cluster
                                    var datasetIds = [];
                                    data.edges.forEach(function (edge) {
                                        if (ni == edge.source ||
                                            ni == edge.target) {
                                            datasetIds.push(edge.datasetId);
                                            node.group = edge.datasetId;
                                        }
                                    });
                                    if (datasetIds.length == 1) {
                                        node.dataset = _.find(data.datasets,
                                            function (d) {
                                                return d.id == datasetIds[0];
                                            });
                                    }
                                }
                            });
                            Datavis.merge(data);
                            promise.resolve();
                        }
                    })
                    return promise;
                });
            });
            chained.done(function () {
                AppProgress.dismiss();
                enableBuildNetwork();
            });
            deferred.resolve();
        })
        dock.hud.append(button);
    });
    var clusterNeighbors = {};
    Datavis.addDockAction(function (nodes) {
        var dock = this;
        var button = JQ(&quot;&lt;button&gt;&quot;).addClass(&quot;btn btn-small&quot;)
            .attr(&quot;id&quot;, &quot;btn-co-neighbors&quot;)
            .css(&quot;margin-left&quot;, 5)
            .attr(&quot;disabled&quot;, !clusters || clusters.length == 0)
            .html(&quot;&lt;i class=\&quot;icon-plus-sign\&quot;&gt;&lt;/i&gt; Co-Neighbors&quot;);
        dock.hud.append(button);
        button.on(&quot;click&quot;, function () { coNeighborAction(clusters, nodes) });
    });
    Datavis.addDockAction(function (nodes) {
        var dock = this;
        var button = JQ(&quot;&lt;button&gt;&quot;).addClass(&quot;btn btn-small&quot;)
            .attr(&quot;id&quot;, &quot;btn-co-neighbors&quot;)
            .css(&quot;margin-left&quot;, 5)
            .html(&quot;&lt;i class=\&quot;icon-external-link\&quot;&gt;&lt;/i&gt; Internal&quot;);
        dock.hud.append(button);
        button.on(&quot;click&quot;, function () { dockInternalNetwork(nodes) });
    })
    function coNeighborAction(clusters, dockedNodes) {
        AppProgress.progress(20); // Some width to indicate doing something
        AppProgress.show(&quot;Getting co-neighbors&quot;);
        var deferred = JQ.Deferred(),
            chained = deferred;
        var clustersDone = 0;
        var dockNeighbors = null;
        var dockFetch = fetchDockGeneNeighbors(dockedNodes)
            .done(function (response) { dockNeighbors = response; });
        var intersections = [];
        clusters.forEach(function (cluster) {
            chained = chained.then(function () {
                if (clusterNeighbors[cluster.entityId]) {
                    return true;
                }
                var codeferred = JQ.Deferred();
                var neighbors = new NetworkModel;
                neighbors.url = neighborTemplate({ id: cluster.entityId });
                neighbors.fetch({
                    data: { datasets: DataSets.asString() },
                    success: function (model, clusterNeighbors) {
                        clusterNeighbors[cluster.entityId] = true;
                        dockFetch.then(function () {
                            var ix = intersectNeighbors(
                                clusterNeighbors, dockNeighbors, dockedNodes
                            );
                            intersections.push(ix);
                            clustersDone++;
                            AppProgress.progress(clustersDone /
                                clusters.length * 100 + &quot;%&quot;);
                            codeferred.resolve()
                        });
                    }
                });
                return codeferred;
            });
        });
        chained.done(function () {
            var NodeIndex = {}, DockIndex = {};
            dockedNodes.forEach(function (node, i) {
                DockIndex[node.entityId] = i;
            });
            var merged = {}, edges = {}, added = {};
            intersections.forEach(function (intersection) {
                if (!intersection.nodes) return;
                intersection.nodes.forEach(function (node) {
                    var id = node.entityId;
                    merged[id] = {
                        datasets: {},
                        edges: [],
                    };
                });
                intersection.edges.forEach(function (edge) {
                    edges[edge.id] = {};
                    [&quot;source&quot;, &quot;target&quot;].forEach(function (side) {
                        var node = intersection.nodes[edge[side]];
                        edges[edge.id][side] = node;
                        // Don't tally datasets for docked nodes (not fair)
                        if (DockIndex[node.entityId] == null) {
                            merged[node.entityId].edges.push(edge);
                            merged[node.entityId].datasets[edge.datasetId] =
                                true;
                        }
                    });
                });
            });
            var added = {};
            var filtered = new Graph();
            function findAdd(node, edge) {
                var gnode = added[node.entityId];
                if (gnode == null) {
                    node.group = edge.datasetId;
                    gnode = filtered.addNode(node);
                    added[node.entityId] = gnode;
                }
                return gnode;
            }
            for (var nid in merged) {
                var ninfo = merged[nid];
                if (_.size(ninfo.datasets) &gt; 1) {
                    ninfo.edges.forEach(function (edge) {
                        var source = findAdd(edges[edge.id].source, edge);
                        var target = findAdd(edges[edge.id].target, edge);
                        filtered.link(source, target, edge);
                    })
                }
            }
            Datavis.merge(filtered.json());
            AppProgress.dismiss();
            enableBuildNetwork();
            Datavis.render();
        });
        deferred.resolve();
    }
    function enableBuildNetwork() {
        clusters = Datavis.find(&quot;CLUSTER&quot;, &quot;type&quot;);
        if (clusters.length) {
            JQ(&quot;#btn-co-neighbors&quot;).attr(&quot;disabled&quot;, false);
            showTable();
        }
    }
    
    function dockInternalNetwork(nodes) {
        modal.emptyBody();
        modal.show();
        var viewport = new Viewport({
            parent: modal.body(),
            id: &quot;dock-internal&quot;,
            toolbar: false,
            title: &quot;Internal Network&quot;,
            maximize: false,
        });
        viewport.css(&quot;min-height&quot;, 400)
        var progress = new Progress({ element: viewport });
        var progressDeferred = JQ.Deferred();
        setTimeout(function () {
            progress.show();
            progressDeferred.resolve();
        }, 1000);
        JQ.ajax({
            url: internalTemplate(),
            data: {
                nodes: _.pluck(nodes, &quot;entityId&quot;).join(&quot;,&quot;),
                datasets: DataSets.asString()
            },
            dataType: &quot;json&quot;,
        }).done(function (data) {
            setTimeout(function () {
                var Internal = new NetworkVis({
                    element: viewport,
                    dock: false,
                    nodeLabel: { type: &quot;GENE&quot; }
                });
                Internal.setData(data);
                Internal.render();
                viewport.renderer(Internal);
                progressDeferred.then(function () {
                    progress.dismiss();
                });
            }, 500);
        })
    }
    function showTable() {
        require(['renderers/table'], function (Table) {
                var div = JQ(&quot;&lt;div&gt;&quot;).attr(&quot;id&quot;, &quot;cluster-list&quot;)
                .addClass(&quot;col-md-1 col-md-offset-2&quot;);
            JQ(&quot;#container&quot;).find(&quot;#cluster-list-row&quot;).remove();
            JQ(&quot;#container&quot;)
                .append(JQ(&quot;&lt;div&gt;&quot;).addClass(&quot;row&quot;)
                .attr(&quot;id&quot;, &quot;cluster-list-row&quot;).append(div));
            var clusterFill = {};
            var table = new Table({
                element: &quot;#cluster-list&quot;,
                scrollY: 100,
                rowCallback: function (row) {
                    JQ(this).css(&quot;background-color&quot;, clusterFill[row[1]]);
                    JQ(this).find(&quot;td&quot;).css(&quot;background-color&quot;,
                        clusterFill[row[1]]);
                }
            });
            var data = [];
            var dockedNodes = {};
            Datavis.dockedNodes().forEach(function (n) {
                dockedNodes[n.entityId] = true;
            });
            clusters.forEach(function (cluster) {
                var neighbors = Datavis.neighbors(cluster);
                var interactions = 0, source = &quot;&quot;, networkType = &quot;&quot;;
                neighbors.forEach(function (tuple) {
                    if (dockedNodes[tuple[0].entityId])
                        interactions++;
                })
                if (cluster.dataset) {
                    networkType = cluster.dataset.networkType;
                    source      = cluster.dataset.sourceReference;
                }
                clusterFill[cluster.entityId] =
                    Datavis.nodeProperty(cluster, &quot;fill&quot;);
                var checkbox = &quot;&lt;input class=\&quot;toggle-cluster\&quot; &quot; +
                    &quot;type=\&quot;checkbox\&quot; checked data-cluster=\&quot;&quot; +
                    cluster.entityId + &quot;\&quot;&gt;&lt;/input&gt;&quot;;
                data.push([
                    checkbox,
                    cluster.entityId,
                    cluster.name,
                    interactions,
                    networkType,
                    source
                ]);
            });
            data = _.sortBy(data, function (d) { return -d[3] });
            table.setData({
                columns: [
                    &quot;&lt;i class=\&quot;icon-eye-open\&quot;&gt;&lt;/i&gt;&quot;, &quot;KBase ID&quot;,
                    &quot;Name&quot;, &quot;Interactions&quot;, &quot;Type&quot;, &quot;Source&quot;
                ],
                data: data
            });
            table.render({
                success: function () {
                    JQ(&quot;.toggle-cluster&quot;).click(function () {
                        if (this._hiddenNode) {
                            Datavis.unhideNode(this._hiddenNode);
                            delete this._hiddenNode;
                        } else {
                            var node = Datavis.findNode(
                                JQ(this).data(&quot;cluster&quot;), &quot;entityId&quot;);
                            node = Datavis.hideNode(node);
                            this._hiddenNode = node;
                        }
                    })
                }
            });
        })
    }
    function fetchDockGeneNeighbors(docked) {
        return JQ.ajax({
            url: neighborQueryTemplate(),
            dataType: &quot;json&quot;,
            data: {
                nodes: _.pluck(docked, &quot;entityId&quot;).join(&quot;,&quot;),
                datasets: DataSets.asString,
                rels: &quot;gg&quot;
            }
        });
    }
    function intersectNeighbors(neighbors1, neighbors2, anchors) {
        var addedAnchor = {};
        if (neighbors1.nodes == null || neighbors1.nodes.length == 0 ||
            neighbors2.nodes == null || neighbors2.nodes.length == 0)
            return {};
        var n1 = new Graph(neighbors1, Graph.INDEXED);
        var n2 = new Graph(neighbors2, Graph.INDEXED);
        var ix = new Graph();
        anchors.forEach(function (anchor) {
            var anchorNode = n2.findNode({ entityId: anchor.entityId });
            if (anchorNode == null) { return; }
            n1.eachNode(function (node) {
                var edge = n2.findEdge(
                    anchorNode, { entityId: node.get('entityId') }
                );
                if (edge) {
                    var ixanchor = addedAnchor[anchor.entityId];
                    if (ixanchor == null) {
                        var ixanchor = ix.addNode(anchorNode);
                        addedAnchor[anchor.entityId] = ixanchor;
                    }
                    var ixnode =
                        ix.findNode({ entityId: node.get('entityId') });
                    if (ixnode == null) {
                        ixnode = ix.addNode(node);
                    }
                    var nedge = ix.link(ixanchor, ixnode, edge.meta);
                }
            });
        });
        return ix.json();
    }
    
    var AppView = Backbone.View.extend({
        el: JQ(&quot;#container&quot;),
        initialize: function () {
            _.bindAll(this, 'render');
            if (NetworkData != null)
                NetworkData.on('reset', this.render);
        },
        render: function () {
            var self = this;
            Datavis.merge(NetworkData.toJSON());
            AppProgress.dismiss();
            return self;
        },
    });
    
    var DataSetModel = Backbone.Model.extend({
        url:   function ()     { return datasetsTemplate(this); },
        parse: function (data) { this.set(&quot;datasets&quot;, data); }
    });
    var DataSets = new DataSetModel;
    DataSets.asString = function () {
        return DataSets.get(&quot;datasets&quot;).join(&quot;,&quot;)
    };
    
    var DataSetView = Backbone.View.extend({
        el: JQ(&quot;#container&quot;),
        initialize: function () {
            _.bindAll(this, 'render');
            DataSets.on('change', this.render);
        },
        template: datasetLinkItemTemplate,
        render: function () {
            var self = this;
            var hud = new HUD({
                position: { top: 50, left: 20 },
                width: 400
            });
            var list = JQ(&quot;&lt;ul&gt;&quot;);
            if (DataSets == null ||
                    DataSets.get('datasets') == null) {
                hud.text(&quot;No datasets&quot;);
            } else {
                var datasets = DataSets.get('datasets');
                hud.append(JQ(&quot;&lt;h4&gt;&quot;).text(&quot;Data Sets&quot;))
                hud.append(list);
                datasets.forEach(function (ds) {
                    list.append(self.template({
                        name: ds.name, desc: ds.description,
                        link: &quot;#node/&quot; + DataSets.get('id') + 
                              &quot;/datasets/&quot; + ds.id
                    }));
                })
                list.append(self.template({
                    name: 'All', desc: &quot;Use all networks&quot;,
                    link: &quot;#node/&quot; + DataSets.get('id') +
                        &quot;/datasets/&quot; + _.pluck(datasets, 'id').join(',')
                }))
            }
            hud.show();
        }
    })
    
    function resetData() {
        JQ(&quot;#cluster-list&quot;).remove();
        Datavis.reset();
        NetworkData.clear({ silent: true });
    }
    
    var SearchBox = Backbone.View.extend({
        el: JQ(&quot;#nav-search&quot;),
        events: { &quot;submit&quot;: &quot;search&quot; },
        search: function (data) {
            var query = JQ(&quot;#nav-search [type=text]&quot;).val();
            resetNetwork = false;
            router.navigate(&quot;#node/&quot; + query, true);
        }
    });
    
    var navbar = new Nav({ el: &quot;#nav-content&quot; });

    function showApp(params) {
        if (params.id == 'fake') {
            DataSets.set('datasets', [&quot;fake&quot;]);
        }
        NetworkData.url = params.url({ id: params.id });
        App = new AppView;
        NetworkData.fetch({
            data: params.fetchData,
            success: function () {
                App.render();
            }
        });
    }
    
    search = new SearchBox;
    var Router = Backbone.Router.extend({
        routes: {
            &quot;node/:id&quot;:                          &quot;addNode&quot;,
            &quot;node/:id/datasets/:sets&quot;:           &quot;addNode&quot;,
            &quot;nodes/:nodes/datasets/:sets&quot;:       &quot;addNodes&quot;,
            &quot;node/:node/datasets&quot;:               &quot;networkDatasets&quot;,
            &quot;node/:id/datasets/:sets/neighbors&quot;: &quot;neighborhood&quot;,
            &quot;network/:nodes/datasets/:sets&quot;:     &quot;internalNetwork&quot;,
            &quot;:network&quot;:                          &quot;showNetwork&quot;,
            &quot;*path&quot;:                             &quot;default&quot;
        },
        addNode: function (nodeId, datasets) {
            if (resetNetwork) { resetData(); }
            NetworkData.set({ id: nodeId });
            Datavis.addNode({ name: nodeId });
            DataSets.set('datasets', datasets.split(&quot;,&quot;));
        },
        addNodes: function (nodeInput, datasetInput) {
            if (blurb) {
                blurb.fadeOut(function () { JQ(this).remove(); });
                setLayout();
            }
            setLayout();
            resetData();
            var nodes = decodeURIComponent(nodeInput).split(&quot;,&quot;);
            var datasets = decodeURIComponent(datasetInput).split(&quot;,&quot;);
            for (var i = 0; i &lt; nodes.length; i++) {
                var type, group;
                type = 'GENE';
                group = 'genes';
                Datavis.addNode({
                    name: nodes[i], entityId: nodes[i], type: type, group: group
                });
            }
            DataSets.set('datasets', datasets);
            Datavis.render();
            Datavis.dockNodes(nodes);
            Datavis.dock.showHUD();
        },
        showNetwork: function (networkId) {
            resetData();
            showApp({
                id: networkId || 'fake',
                url: networkTemplate
            })
        },
        networkDatasets: function (nodeId) {
            DataSets.set({ id: nodeId });
            var datasetView = new DataSetView();
            DataSets.fetch({
                success: function () { AppProgress.dismiss(); }
            });
        },
        neighborhood: function (id, datasets) {
            showApp({
                id: id,
                url: neighborTemplate,
                fetchData: { datasets: datasets }
            });
            DataSets.set('datasets', datasets.split(&quot;,&quot;));
        },
        internalNetwork: function (nodes, datasets) {
            AppProgress.show(&quot;Building&quot;);
            showApp({
                id: &quot;internal&quot;,
                url: internalTemplate,
                fetchData: { datasets: datasets, nodes: nodes }
            });
        },
        default: function () {
            JQ(&quot;#datavis&quot;).empty();
            JQ(&quot;#cluster-list&quot;).remove();
            blurb = new Blurb({ parent: &quot;#datavis&quot;, router: router });
        }
    });
    router = new Router;
    Backbone.history.start();
    var help = new Help({
        template: &quot;/templates/network-help.html&quot;,
        title: &quot;Using the Network Workbench&quot;
    });
    modal.init();
});</pre>
</body>
</html>
