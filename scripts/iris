#!/bin/bash

SCRIPTDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
IRIS_HOME=${IRIS_HOME:-`cd $SCRIPTDIR/.. && pwd -P`}
NODEDIR=$IRIS_HOME/nodejs
CONFDIR=$IRIS_HOME/conf
SVC_DIR=$NODEDIR/services
SVC_CONF=$CONFDIR/services.json
LOGDIR=$IRIS_HOME/logs
PIDFILE=$LOGDIR/iris.pid
SVCPIDFILE=$LOGDIR/service.%%.pid
INSTALL_LOG=$LOGDIR/install.log
HOSTNAME=http://0.0.0.0

IRIS_USAGE='iris [options] <command> [<arguments>]
    
Available commands:
    help        This command
    install     Install dependencies required by Iris
    open        Open up an Iris session (Mac only, for now)
    start       Start Iris
    stop        Stop Iris
    restart     Restart Iris
    services    Lists available services
    status      Check whether or not Iris is running
    check       Ensure that Iris is ready to go
    
"iris help <command>" shows help on specific commands.'


mkdir -p $LOGDIR

# ===========================================================================
# Private utility functions

function _error {
    tput bold; printf "Error: "; tput sgr0
    echo $@
    echo
}

function _json_flatten {
    jsonfile=$1
    key=$2
    fields=$3
    perl -MJSON -e "
        my \$d = decode_json(join '',<STDIN>)->{$key};
        print
            join(\"\n\",
                map {
                    my \$j=\$_; join(\"\t\",
                        map { \$j->{\$_} } qw/$fields/
                    )
                } @\$d), \"\n\"
    " < $jsonfile
}

function _running_pid {
    pidfile=$1
    if [ -e "$pidfile" ]; then
        xargs ps u -p < $pidfile | awk '!/PID/ {print $2}'
    fi
}

function _iris_pid {
    _running_pid $PIDFILE
}

function _svc_pidfile {
    svc=$1
    echo $SVCPIDFILE | sed "s/%%/$svc/"
}

function _start_services {
    svc=$1
    if [ ! -e "$SVC_CONF" ]; then
        echo "Service configuration [$SVC_CONF] cannot be found!"
        iris_cmd_help
        exit 1
    fi
    echo "Starting services..."
    if [ -n "$svc" ]; then
        list_services="iris_cmd_services | awk '\$2==\"$svc\"{print}'"
    else
        list_services='iris_cmd_services'
    fi
    eval $list_services | (while read line
        do
            local service=($line)
            local port=${service[0]}
            local name=${service[1]}
            local nodefile=${service[2]}
            local conffile=${service[3]}
            local log=$LOGDIR/$name.log
            pidfile=`_svc_pidfile $name`
            pid=`_running_pid $pidfile`
            if [ -n "$pid" ]; then
                echo "Service $name is already running as process $pid"
                continue
            fi
            NODE_PORT=$port node $SVC_DIR/$nodefile $CONFDIR/$conffile $name > $log &
            echo $! > $pidfile
        done
        wait
    ) &
    sleep 1
    irispid=$!
}

function _start_all_iris {
    pid=`_iris_pid`
    if [ -n "$pid" ]; then
        echo "Iris is already running (pid `cat $PIDFILE`)"
    else
        _start_services
        if [ -n "$irispid" ]; then
            echo $irispid > $PIDFILE
            iris_cmd_status
        else
            echo "Error launching Iris"
        fi
    fi
}

function _status_line {
    printf "%-20s %-10s %s\n" $1 $2 $3
}

function _find_service {
    local svc=$1
    local service=(`iris_cmd_services | awk "\\\$2==\"\$svc\"{print}"`)
    echo "${service[*]}"
}

function _service_status {
    local service=($@)
    local name=${service[1]}
    local pidfile=`_svc_pidfile $name`
    if [ ! -e "$pidfile" ]; then
        echo "Service '$name' is not running."
        return
    fi
    local port=${service[0]}
    _status_line $name `_running_pid $pidfile` "$HOSTNAME:$port"
}

# ===========================================================================
# Iris commands

# ---------------------------------------------------------------------------
# IRIS START
# ---------------------------------------------------------------------------
_help_start="iris start [<service>]

Starts Iris services. With no arguments, starts all services.
    <service>   Start a specific service"
function iris_cmd_start {
    svc=$1
    if [ -n "$svc" ]; then
        if [ `iris_cmd_services | cut -f2 | grep -c "\b$svc\b"` -eq 0 ]; then
            echo "Service $svc is not a valid service!"
            exit 1
        fi
        pidfile=`_svc_pidfile $svc`
        pid=`_running_pid $pidfile`
        if [ -n "$pid" ]; then
            echo "Service $svc is already running!"
            return
        fi
        _start_services $svc
        iris_cmd_status $svc
    else
        _start_all_iris
    fi
}

# ---------------------------------------------------------------------------
# IRIS STOP
# ---------------------------------------------------------------------------
_help_stop="iris stop [<service>]

Stops Iris services. With no arguments, stops all of Iris.
    <service>   Stop a specific service"
function iris_cmd_stop {
    svc=$1
    if [ -n "$svc" ]; then
        if [ `iris_cmd_services | cut -f2 | grep -c "\b$svc\b"` -eq 0 ]; then
            echo "Service $svc is not a valid service!"
            exit 1
        else
            pidfile=`_svc_pidfile $svc`
            if [ ! -e "$pidfile" ]; then
                echo "Service $svc is not running!"
                return
            fi
            kill `_running_pid $pidfile`
            rm -f $pidfile
            echo "Stopped service $svc."
        fi
    else
        irispid=`_iris_pid`
        if [ -n "$irispid" ]; then
            # Kill children
            ps -o pid,ppid -ax | awk "\$2==$irispid{print \$1}" | xargs kill
            echo "Iris successfully stopped."
        else
            echo "Iris is not running."
        fi
        # In case services are started separately
        for pidfile in `_svc_pidfile '*'`; do
            local pid=`_running_pid $pidfile`
            # Kill standalone service process
            if [ -n "$pid" ]; then
                if [ -z "$irispid" ]; then
                    echo "Killing standalone service '`
                            basename $pidfile|sed 's/service\.\(.*\)\.pid/\1/'
                        `'"
                fi
                kill $pid
            fi
        done
        # Handle both standard shutdown and when Iris is not running but the
        # pid file still exists.
        rm -f $PIDFILE `_svc_pidfile '*'`
    fi 
}

# ---------------------------------------------------------------------------
# IRIS INSTALL
# ---------------------------------------------------------------------------
_help_install="iris install [-q] [<component>]

Installs various components and dependencies required by Iris. If <component> 
is specified, only that component is installed. All output from the various 
installations is redirected to
    $INSTALL_LOG
    
Options:
    -q          Suppress friendly messages to the shell

The following components are available:

    node        Various modules required by Node.js
    jquery      Compiles the jQuery library
    fastbit     Compiles the Fastbit library and Iris extensions for Fastbit"
function iris_cmd_install {
    local verbose=1
    while getopts "q" opt; do
        case $opt in
            q) verbose=0;;
            *)
                echo "'iris install' does not support the -$opt option!"
                iris_cmd_help install
                ;;
        esac
        shift
    done

    component=$1
    if [ -n "$component" ]; then
        if [ "$component" != 'fastbit' -a \
             "$component" != 'jquery' -a \
             "$component" != 'node' ]; then
            echo "Install component '$component' is not recognized!"
            iris_cmd_help install
        fi
    else
        component="all"
    fi
    
    cd $IRIS_HOME
    cat <<LOG_HEADER >> $INSTALL_LOG
=======================================
Installation - $component - `date`

LOG_HEADER
    # Fetch git-managed modules
    
    [ "$verbose" -eq 1 ] && echo "Installing Git modules..."
    git submodule update --init 2>&1 >> $INSTALL_LOG

    if [ "$component" == "all" -o "$component" == "node" ]; then
        [ "$verbose" -eq 1 ] && echo "Installing Node modules..."
        # Install Node.js dependencies
        cd $IRIS_HOME/nodejs
        npm install 2>&1 >> $INSTALL_LOG
    fi
    
    if [ "$component" == "all" -o "$component" == "jquery" ]; then
        [ "$verbose" -eq 1 ] && echo "Compiling jQuery library..."
        # Compile jQuery library
        cd $IRIS_HOME/external/jquery
        git submodule update --init 2>&1 >> $INSTALL_LOG
        make 2>&1 >> $INSTALL_LOG
    fi
    
    if [ "$component" == "all" -o "$component" == "fastbit" ]; then
        [ "$verbose" -eq 1 ] &&
            echo "Compiling Fastbit... (Hang on. This might take a while.)"
        # Install FastBit
        cd $IRIS_HOME/fastbit
        ./configure --prefix $IRIS_HOME 2>&1 >> $INSTALL_LOG
        make 2>&1 >> $INSTALL_LOG # Now take a [long] coffee break
        make check 2>&1 >> $INSTALL_LOG
        make install 2>&1 >> $INSTALL_LOG
    fi
}

# ---------------------------------------------------------------------------
# IRIS INSTALL
# ---------------------------------------------------------------------------
_help_help="iris help [<command>]

Provides help for commands. With no arguments, shows brief help for each 
command.

    <command>   Specific command to get help for"
function iris_cmd_help {
    cmd=$1
    if [ -n "$cmd" ]; then
        if [ -z "$(declare -f iris_cmd_$cmd)" ]; then
            echo "There's no command called '$cmd'"
        else
            eval "help_message=\$_help_$cmd"
            if [ -z "$help_message" ]; then
                echo "No help currently available for 'iris $cmd'"
            else
                cat <<HELP
$help_message
HELP
            fi
        fi
        exit 0
    fi
    cat <<HELP
$IRIS_USAGE
HELP
}

# ---------------------------------------------------------------------------
# IRIS OPEN
# ---------------------------------------------------------------------------
_help_open="iris open

Opens a browser window with the Iris website. This option is currently only 
supported by Mac (Srsly, why would you use anything else?)."
function iris_cmd_open {
    proxy_service='iris' # TODO: Name it something else?
    port=`_find_service $proxy_service | awk '{print $1}'`
    open $HOSTNAME:$port
}

# ---------------------------------------------------------------------------
# IRIS STATUS
# ---------------------------------------------------------------------------
_help_status="iris status [<service>]

Shows the status of running services.

    <service>   Show status only for this service
    
See also: 'iris services'"
function iris_cmd_status {
    svc=$1
    if [ -n "$svc" ]; then
        local service=(`_find_service $svc`)
        if [ "${#service[@]}" -eq 0 ]; then
            echo "Service '$svc' is not a valid service!"
            iris_cmd_help status 
        fi
        _status_line "SERVICE" "PID" "URL"
        _service_status ${service[@]}
    else
        pid=`_iris_pid`
        if [ -z "$pid" ]; then
            echo "Iris is not running."
        else
            echo "Iris is running as process $pid with the following services:"
        fi
        iris_cmd_services | cut -f2 | while read name; do
            local service=(`_find_service $name`)
            local pid=$(_running_pid $(_svc_pidfile $name))
            if [ -n "$pid" ]; then
                if [ -z "$service_running" ]; then
                    _status_line "SERVICE" "PID" "URL"
                    local service_running=1
                fi
                _service_status ${service[@]}
            fi
        done
    fi
}

# ---------------------------------------------------------------------------
# IRIS SERVICES
# ---------------------------------------------------------------------------
_help_services="iris services

Lists available service currently configured with Iris (not *running* services).

See also: 'iris status'"
function iris_cmd_services {
    _json_flatten $SVC_CONF "services" "port name nodefile config"
}

# ---------------------------------------------------------------------------
# IRIS RESTART
# ---------------------------------------------------------------------------
_help_restart="iris restart [<service>]

Restarts Iris services. With no arguments, restarts all services.

    <service>   Restart a specific service"
function iris_cmd_restart {
    iris_cmd_stop $@
    iris_cmd_start $@
}


# ---------------------------------------------------------------------------
# IRIS EXAMPLES
# ---------------------------------------------------------------------------
_help_check="iris examples

Install example data."
function iris_cmd_examples {
    local overwrite=$1
    EXAMPLEDIR=./examples
    cd $IRIS_HOME
    git submodule update --init -- $EXAMPLEDIR > /dev/null
    cd $EXAMPLEDIR
    if [ -z "$(which mongorestore 2> /dev/null)" ]; then
        _error "Cannot find the command 'mongorestore', required for loading
              the example data"
        exit 1
    fi
    dbs=$(echo 'show dbs' | mongo --quiet | cut -f1 | grep -v '^bye$')
    for f in ./mongo/*; do
        db=$(basename $f)
        if [ "$(echo $dbs | grep -c "$db")" -eq 1 -a \
            "$overwrite" != "-f" ]; then
            echo "Database '$db' already exists. Use '-f' to overwrite."
        else
            echo "Loading database '$db'"
            mongorestore --drop $f
        fi
    done
}

# ---------------------------------------------------------------------------
# IRIS CHECK
# ---------------------------------------------------------------------------
_help_check="iris check [<component>]

Checks to ensure the Iris installation is complete and ready to go. With no
argument, runs all component checks.

The following modules are supported:

    unit        Only run the Iris unit tests
    files       Only check file structure"
function iris_cmd_check {
    local component=$1
    
    if [ -n "$component" ]; then
        if [ "$component" != "unit" -a \
             "$component" != "files" ]; then
             _error "'$component' is not a valid check component"
             iris_cmd_help check
         fi
    else
        component="all"
    fi

    cd $IRIS_HOME
    local errnum=0
    declare -a errors=()
    function add_error {
        errors[$errnum]="$1"
        errnum=$(($errnum+1))
    }
    
    if [ "$component" == "all" -o "$component" == "files" ]; then

        # Ensure required files exist
        for f in $SVC_CONF bin/fbsql bin/scatter bin/ranges lib/libfastbit.a; do
            if [ ! -e "$f" ]; then
                add_error "Required file '$f' is missing."
            fi
        done
    
        # Ensure services.json is valid JSON
        if [ -e "$SVC_CONF" -a \
            -n "$( (/usr/bin/python -mjson.tool <$SVC_CONF>/dev/null) 2>&1)" ]
        then
            add_error "Service configuration '${SVC_CONF##$IRIS_HOME/}' is
                       not valid JSON."
        fi
    
        # Ensure 'logs' is writable
        if [ -e "$LOGDIR" -a ! -w "$LOGDIR" ]; then
            add_error "Log directory '${LOGDIR##$IRIS_HOME/}' 
                       exists but is not writable."
        fi
    
        # Check for required executables
        for executable in node npm mongo; do
            if [ -z "$(which $executable 2> /dev/null)" ]; then
                add_error "Command '$executable' was not found in your path."
            fi
        done
    
        if [ "$errnum" -gt 0 ]; then
            tput bold; echo "Errors:"; tput sgr0
            for ((i = 0; i < ${#errors[@]}; i++)); do
                echo ${errors[$i]}
            done
            exit 0;
        else
            echo "Files lookin' good."
        fi
    fi
    
    if [ "$component" == "all" -o "$component" == "unit" ]; then
    
        # NODEUNIT
        export NODE_PATH=$NODEDIR/node_modules
        cd $IRIS_HOME/test/
        ./testjs
    fi
}

# 'MAIN'
cmd=$1
if [ `declare -f iris_cmd_$cmd | wc -l` -gt 1 ]; then
    shift
    eval "iris_cmd_$cmd \$@"
else
    echo "Unrecognized command. Try 'iris help'"
fi
